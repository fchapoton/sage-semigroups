r"""
Sets with a distinguished action of a semigroup

EXAMPLES:

Let us start with an automaton, with three states 1,2,3, and encoded
as a :class:`DiGraph`::

    sage: automaton = DiGraph( [ (1, 1, "b"), (1, 2, "a"),
    ...                          (2, 2, "a"), (2, 2, "c"), (2, 3, "b"),
    ...                          (3, 2, "a"), (3, 3, "b"), (3, 3, "c") ] )
    sage: automaton.show(edge_labels=True)

The free monoid with generators a,b,c acts via the transition function
on this automaton. For example, acting by "a" on 1 gives 2::

    sage: automaton.transition(1, "a")
    2

Let us construct the set of vertices of ``automaton``, endowed with
the action of the free monoid::

    sage: M = automaton.transition_module(); M
    {1, 2, 3} endowed with an action of The transition monoid of Looped multi-digraph on 3 vertices

The Cayley graph of this action is the original graph::

    sage: M.cayley_graph().edges()
    [(1, 1, 'b'), (1, 2, 'a'), (2, 2, 'a'), (2, 2, 'c'), (2, 3, 'b'), (3, 2, 'a'), (3, 3, 'b'), (3, 3, 'c')]

This set has two classes, which correspond to the two strongly
connected components of ``automaton``::

    sage: M.classes()
    [{1}, {2, 3}]
    sage: automaton.strongly_connected_components()
    [[1], [2, 3]]

Let us take the second class::

    sage: c = M.class_of(2); c
    {2, 3}

It is stable under the action, so we can construct the submodule::

    sage: N = M.submodule(c)
    sage: N.cayley_graph().edges()
    [(2, 2, 'a'), (2, 2, 'c'), (2, 3, 'b'), (3, 2, 'a'), (3, 3, 'b'), (3, 3, 'c')]

The first class is not a submodule; however it can be endowed with a
subquotient structure by killing all outgoing edges::

    sage: N = M.subquotient(M.class_of(1))
    sage: N.cayley_graph().edges()
    [(1, 1, 'b')]



Let us now consider an `H`-trivial monoid::

    sage: O3 = HTrivialMonoids().Finite().example(); O3
    The finite H-trivial monoid of order preserving maps on {1, .., 3}
    sage: O3.rename("O3")

Its generators are::

    sage: pi = O3.monoid_generators(); pi
    Finite family {1: 113, 2: 122, -2: 133, -1: 223}

The left classes of `O_3` are::

    sage: l_classes = sorted([sorted(l_class, key=str) for l_class in O3.l_classes()], key = lambda l_class: str(l_class[-1])); l_classes
    [[123], [112, 113, 223], [122, 133, 233], [111, 222, 333]]

.. note:: We sorted them, in order for the results below to be reproducible.

Let us endow them with the natural action of `O_3` constructed as
subquotient for the left regular action::

    sage: reg = O3.with_regular_action(side="left"); reg
    O3 endowed with an action of O3
    sage: l_classes = [reg.subquotient(l_class) for l_class in l_classes]

Let's look at the second left class::

    sage: l_class = l_classes[1]; l_class
    {112, 113, 223} endowed with an action of O3
    sage: l_class.cayley_graph().edges()
    [(113, 113, -2), (113, 113, 1), (113, 223, -1), (113, 112, 2), (223, 113, 1), (223, 223, -1), (112, 113, -2), (112, 112, 2)]
    sage: x = l_class[0];  x
    112
    sage: l_class.action(pi[-2], x)
    113
    sage: l_class.action(pi[1], x)

This left class is isomorphic to the third left class::

    sage: l_class.is_isomorphic(l_classes[2])
    True

This is because ``l_classes[1]`` and ``l_classes[2]`` both belong to
the same `J`-class::

    sage: O3.j_classes().map(sorted)
    Finite family {0: [123], 1: [113, 133, 112, 122, 223, 233], 2: [111, 222, 333]}

However, ``l_class`` is not isomorphic to the last left class::

    sage: l_class.is_isomorphic(l_classes[3])
    False

We now build the corresponding left class modules::

    sage: Kl_classes = [l_class.algebra(QQ) for l_class in l_classes]

    sage: Kl_class = Kl_classes[2]; Kl_class
    Free module generated by {122, 133, 233} endowed with an action of O3 over Rational Field
    sage: x = Kl_class.an_element(); x
    2*B[122] + 2*B[133] + 3*B[233]
    sage: Kl_class.action(pi[1], x)
    5*B[133]

It is possible to embed the first left class as a submodule of the
second::

    sage: l_classes[0].hom_to_module(Kl_classes[2])
    Vector space of degree 3 and dimension 1 over Rational Field
    Basis matrix:
    [ 1 -1  1]

Similarly, it is possible to embed the second left class as a
submodule of the last::

    sage: l_classes[1].hom_to_module(Kl_classes[3])
    Vector space of degree 3 and dimension 1 over Rational Field
    Basis matrix:
    [ 1 -1  0]

Characters
----------

As for groups, characters provide a convenient computational tool to
recover the composition factors of a module `V` (although those
composition factors are not sufficient to completely describe the
structure of `V`). Let us take for example the left regular
representation::

    sage: V = O3.regular_representation(side="left", base_ring = QQ)
    sage: chi = V.character(); chi
    10*C[0] + 6*C[1] + 3*C[2]

It encodes the trace of appropriate idempotents of `O_3` when acting
on `V`. In particular, the identity is of trace `10` since `V` is of
dimension `10`. It is returned as an element of the *character ring*
of `V` whose elements model formal \ZZ linear combinations of
modules (aka virtual characters)::

    sage: G = O3.character_ring(QQ, side="left"); G
    The left-character ring of O3 over Rational Field

This ring admits several bases::

    sage: C = G.C(); C
    The left-character ring of O3 over Rational Field in the basis of characters of left-class functions modules
    sage: S = G.S(); S
    The left-character ring of O3 over Rational Field in the basis of characters of simple left modules
    sage: P = G.P(); P
    The left-character ring of O3 over Rational Field in the basis of characters of projective indecomposable left modules
    sage: T = G.T(); T
    The left-character ring of O3 over Rational Field in the basis of characters of regular left-class modules

By changing bases one can calculate how a module could possibly
decompose in term of various modules. For example, here are the
composition factors of the regular representation::

    sage: S(V.character())
    3*S[0] + 3*S[1] + S[2]

Here are the composition factors of projective modules and left class
modules::

    sage: for chi in P.basis():
    ...       print "%s = %s"%(chi, S(chi))
    P[0] = S[0] + S[1]
    P[1] = S[1] + S[2]
    P[2] = S[2]

    sage: for chi in T.basis():
    ...       print "%s = %s"%(chi, S(chi))
    T[0] = S[0]
    T[1] = S[0] + S[1]
    T[2] = S[1] + S[2]

This shows that `V` could possibly have a composition series in term
of right class modules (and here, it does!)::

    sage: T(V.character())
    T[0] + 2*T[1] + T[2]

"""
#*****************************************************************************
#  Copyright (C) 2011 Nicolas M. Thiery <nthiery at users.sf.net>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

import functools
from sage.cpython.getattr import raw_getattr
from sage.misc.cachefunc import cached_function, cached_method
from sage.misc.constant_function import ConstantFunction
from sage.misc.abstract_method import abstract_method
from sage.categories.category import Category
from sage.categories.sets_cat import Sets
from sage.categories.algebra_functor import AlgebrasCategory
from sage.categories.subquotients import SubquotientsCategory
from sage.categories.set_with_action_functor import SetsWithActionCategory

class SetsWithAction(SetsWithActionCategory):

    @cached_method
    def extra_super_categories(self):
        r"""
        Return the list of the (immediate) super categories of
        ``self``, as per :meth:`Category.super_categories`.

        EXAMPLES::

            sage: Semigroups().SetsWithAction().super_categories()
            [Category of sets]

        """
        return [Sets()]

    def example(self):
        """
        EXAMPLES::

            sage: M = Semigroups().SetsWithAction().example()
            sage: TestSuite(M).run(skip = ["_test_pickling"])

        """
        from sage.monoids.representations import SetWithAction
        from sage.rings.finite_rings.integer_mod_ring import IntegerModRing
        from sage.sets.finite_set_maps import FiniteSetMaps
        from sage.combinat.automatic_monoid import AutomaticMonoid
        from sage.sets.family import Family
        from sage.combinat.j_trivial_monoids import SubFiniteMonoidsOfFunctions

        Z = IntegerModRing(10)
        ambient = FiniteSetMaps(Z)
        S = AutomaticMonoid(Family({2: ambient(lambda x: 2*x), 3: ambient(lambda x: 3*x) }), category=SubFiniteMonoidsOfFunctions())
        M = SetWithAction(S, Z, action = lambda f,m: f(m))
        M.rename("Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication")
        return M

    class ParentMethods:

        @abstract_method
        def semigroup(self):
            """
            Return the semigroup acting on ``self``

            EXAMPLES::

                sage: M = Semigroups().SetsWithAction().example(); M
                Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                sage: M.semigroup()
                The (automatic) monoid with generators Finite family {...}
            """

        @abstract_method
        def action(self, s, x):
            """
            Return the action of `s` on `x`

            INPUT:
            - ``s`` -- an element of the semigroup acting on ``self``
            - ``x`` -- an element of ``self``

            EXAMPLES::

                sage: M = Semigroups().SetsWithAction().example(); M
                Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                sage: f2,f3 = M.semigroup().semigroup_generators()
                sage: f2.lift()
                map: 0 -> 0, 1 -> 2, 2 -> 4, 3 -> 6, 4 -> 8, 5 -> 0, 6 -> 2, 7 -> 4, 8 -> 6, 9 -> 8
                sage: [ M.action(f2, x) for x in M]
                [0, 2, 4, 6, 8, 0, 2, 4, 6, 8]
            """

        @cached_method
        def cayley_graph(self, simple = False, elements = None, generators = None):
            """
            Return the Cayley graph of ``self``

            EXAMPLES::

                sage: M = Semigroups().SetsWithAction().example(); M
                Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                sage: G = M.cayley_graph()
                sage: G.edges()
                [(0, 0, 2), (0, 0, 3), (1, 2, 2), (1, 3, 3),
                 (2, 4, 2), (2, 6, 3), (3, 6, 2), (3, 9, 3),
                 (4, 2, 3), (4, 8, 2), (5, 0, 2), (5, 5, 3),
                 (6, 2, 2), (6, 8, 3), (7, 1, 3), (7, 4, 2),
                 (8, 4, 3), (8, 6, 2), (9, 7, 3), (9, 8, 2)]

            Let us look at the graph::

                sage: G.set_latex_options(format='dot2tex', edge_labels=True)  # optional - requires dot2tex and graphviz
                sage: view(G, tightpage=True, pdflatex=True)                   # optional - requires dot2tex and graphviz

            The Cayley graph as a simple graph (no loops, no labels)::

                sage: G = M.cayley_graph(simple=True)
                sage: G.edges()
                [(1, 2, None), (1, 3, None),
                 (2, 4, None), (2, 6, None), (3, 6, None), (3, 9, None),
                 (4, 2, None), (4, 8, None), (5, 0, None),
                 (6, 2, None), (6, 8, None), (7, 1, None), (7, 4, None),
                 (8, 4, None), (8, 6, None), (9, 7, None), (9, 8, None)]
            """
            # This is duplicated from semigroups.cayley_graph
            from sage.graphs.digraph import DiGraph
            if elements is None:
                assert self._set.is_finite(), "elements should be specified for infinite modules"
                elements = tuple(self._set)
            elements_set = set(elements)
            if simple:
                result = DiGraph()
            else:
                result = DiGraph(multiedges = True, loops = True)
            result.add_vertices(elements)

            if generators is None:
                generators = self.semigroup().semigroup_generators()
            if isinstance(generators, (list, tuple)):
                generators = dict((self(g), self(g)) for g in generators)
            def add_edge(source, target, label):
                """
                Skips edges whose targets are not in elements
                Return an appropriate edge given the options
                """
                if target not in elements_set: return
                if simple:
                    if source != target:
                        result.add_edge([source, target])
                else:
                    result.add_edge([source, target, label])
            for x in elements:
                for i in generators.keys():
                    add_edge(x, self._action(generators[i],x), i)
            return result

        @cached_method
        def classes(self): # Or discrete composition_series?
            r"""
            Return the classes of ``self``

            The classes of ``self`` are the strongly connected components
            of its Cayley graph. For a group, those would be the orbits.

            EXAMPLES::

                sage: M = Semigroups().SetsWithAction().example(); M
                Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                sage: M.classes()
                [{1, 3, 9, 7}, {5}, {0}, {8, 2, 4, 6}]

            This for example means that, in `\ZZ/10\ZZ`, any element of
            ``\{1,3,9,7\}`` is reachable from any other by successive
            multiplications by `2` and `3`.

            .. seealso: :meth:`cayley_graph`, :meth:`class_of`
            """
            G = self.cayley_graph(simple=True).strongly_connected_components_digraph()
            from sage.combinat.posets.posets import Poset
            P = Poset(G, facade=True)
            return P.linear_extension()

        # note: this cannot be self.class(x) since class is a keyword
        @cached_method
        def class_of(self, x):
            """
            Return the class of `x` in ``self``

            .. seealso: :meth:`classes` for the definition of class

            EXAMPLES::

                sage: M = Semigroups().SetsWithAction().example(); M
                Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                sage: M.class_of(3)
                {1, 3, 9, 7}

            TESTS::

                sage: assert all( x in M.class_of(x) for x in M )
            """
            for cls in self.classes():
                for y in cls:
                    self.class_of.set_cache(cls, y)
            return self.class_of(x)

        def module_generator(self):
            r"""
            Return a generator of ``self`` under the action of ``self.semigroup()``.

            This assumes that ``self`` is cyclic, or equivalently that
            it has a single generator or that its Cayley graph is
            strongly connected.

            .. todo:: find another name than ``module`` ...

            EXAMPLES::

                sage: M = DiGraph([(0, 0, -3), (0, 0, 3), (0, 1, -4), (0, 3, 2),
                ...                (1, 0, 3), (1, 1, -4), (1, 1, 4),
                ...                (2, 1, -4), (2, 2, -3), (2, 2, 3), (2, 3, 2),
                ...                (3, 2, -3), (3, 3, -2), (3, 3, 2)
                ...               ]).transition_module()
                sage: M.module_generator()
                0
            """
            assert self.cayley_graph().is_strongly_connected()
            return self.first()

        def nr_fixed_points(self, s):
            """
            Return the number of fixed points for the action of `s` on ``self``

            INPUT:
            - `s` -- an element of the semigroup acting on ``self``

            EXAMPLES::

                sage: S = AperiodicMonoids().Finite().example(3); S
                The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: A = S.lr_regular_class(1, side="left")
                sage: sorted(A.cayley_graph().edges())
                [(113, 113, -2), (113, 113, 1), (113, 223, -1), (113, 112, 2), (223, 113, 1), (223, 223, -1), (112, 113, -2), (112, 112, 2)]
                sage: pi = S.monoid_generators()
                sage: pi
                Finite family {1: 113, 2: 122, -2: 133, -1: 223}
                sage: A.nr_fixed_points(S.one())
                3
                sage: A.nr_fixed_points(pi[1])
                1
            """
            # TODO: don't build the list!
            return len( [ x for x in self if self.action(s,x) == x ] )

        ######################################################################
        # Isomorphisms, embeddings, ...

        @cached_method
        def canonical_label(self):
            result = self.cayley_graph().canonical_label()
            result.weighted(True) # otherwise edges labels are ignored in comparisons
            return result

        def is_isomorphic(self, other):
            """
            EXAMPLES::

                

            .. note:: we do not need to check that the semigroups are
                the same.  It is sufficient that the generators act
                identically. We might want to check that the index of
                the semigroup generators are the same though.
            """
            return self.canonical_label() == other.canonical_label()

        def hom_to_module(self, module):
            """
            INPUT:

            - ``module`` -- a vector space affording a representation
                of ``self.semigroup()`` implemented as ``module.action(s, x)``

            Assume that this module is cyclic, with generator `g` (see
            :meth:`module_generator`), and let `S` be the semigroup
            acting on ``self`` (see :meth:`self.semigroup`). For
            short, we write `x . s` the action of `s` on `x`.

            This returns the subspace `M` of all elements `x` of
            ``module`` such that `g \mapsto x` extends to a morphism
            of `S`-modules; equivalently `x` must satisfy the
            following system of linear equations:

            .. math:  g . s = None  \Rightarrow x . s = 0,       \forall s\in S
            .. math:  g . s == g. t \Rightarrow x . s == x . t,  \forall s,t\in S

            In practice, the system of equation can be reduced to one
            equation for each pair `u,i` with `u` in ``self`` and `i`
            index of a semigroup generator of `S`.

            EXAMPLES::

            The cayley graph of the regular left class of the bi-Hecke
            monoid indexed by 13452::

                sage: big = DiGraph([(0, 0, -3), (0, 0, 3), (0, 1, -4), (0, 3, 2),
                ...                (1, 0, 3), (1, 1, -4), (1, 1, 4),
                ...                (2, 1, -4), (2, 2, -3), (2, 2, 3), (2, 3, 2),
                ...                (3, 2, -3), (3, 3, -2), (3, 3, 2)
                ...               ]).transition_module()
                sage: small = DiGraph([(0, 0, -2), (0, 0, 2)]).transition_module()

            """
            from sage.misc.misc import attrcall
            alphabet = self.semigroup().semigroup_generators().keys()
            S = module.semigroup()
            s = S.semigroup_generators()
            assert set(alphabet).issubset(set(s.keys()))

            # Let's see they Cayley graph of ``self`` as an automaton
            G = self.cayley_graph()
            # Now we build, for each vertex `u`, a shortest word `w_u` in the
            # alphabet mapping ``self.module_generator()`` to `u`.
            # Below we write `s_{w_u}` for the element of the semigroup
            # corresponding to `w_u`.
            paths = G.shortest_paths(self.module_generator())
            words = dict( (u, tuple( G.edge_label(path[i],path[i+1])[0]  for i in range(len(path)-1) ))
                          for u,path in paths.iteritems() )
            @cached_function
            def word_action(word, x):
                """
                INPUT:

                 - ``word`` -- a tuple `i_1,\dots,i_k` in the
                   generators of ``S`` representing a path in ``G``
                 - ``x`` -- and element of ``module``

                Writing x.s for the result of the action of `s\in S`
                on `x`, this returns ``x.s_{i_1}.\dots.s_{i_k}``.

                The result is cached over prefixes. This function will
                only be called for `x` in the basis of ``module``.
                """
                if len(word) == 0:
                    return x
                else:
                    return module.action(s[word[-1]], word_action(word[:-1], x))

            def biword_action(word1, word2, x):
                """
                Return the difference of the action of word1 and word2 on `x`
                """
                return word_action(word1,x) - word_action(word2,x)

            # Build the equations, encoded as linear morphisms
            morphisms = []
            alphabet = S.semigroup_generators().keys()
            for u in G.vertices():
                for i in alphabet:
                    v = G.transition(u,i)
                    if v is None:
                        # Add morphism `x -> x . s_{w_u} s_i`
                        morphisms.append( functools.partial(word_action, words[u]+(i,) ) )
                    else:
                        # Add morphism `x ->  x . s_{w_u} s_i - x . s_{w_v}`
                        morphisms.append( functools.partial(biword_action, words[u]+(i,), words[v] ) )
            # Computes the joint kernel of those morphisms.
            return module.annihilator( morphisms, action = attrcall("__call__"), side = "left" )

    class Subquotients(SubquotientsCategory):

        class ParentMethods:

            @cached_method
            def semigroup(self):
                r"""

                """
                return self.ambient().semigroup()

            @cached_method
            def side(self):
                """
                Returns on which side the action occurs

                EXAMPLES::

                    sage: M = HTrivialMonoids().Finite().example()
                    sage: M.simple_module(1, side='left').side()
                    'left'
                    sage: M.simple_module(1, side='right').side()
                    'right'
                    sage: M.simple_module(1, side='right').side.__module__
                    'sage.categories.sets_with_action'
                """
                return self.ambient().side()

            def action(self, s, x):
                r"""

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example(); M
                    Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication
                    sage: M.classes()
                    [{1, 3, 9, 7}, {5}, {0}, {8, 2, 4, 6}]

                    sage: N = M.submodule(Set([2, 4, 6, 8]))
                    sage: list(N)
                    [0, 1, 3, 5, 7, 9]

                """
                return self.retract(self.ambient().action(s, self.lift(x)))

    class Algebras(AlgebrasCategory):
        """
        EXAMPLES::

        Oops, the pretty printing is broken (the `s` is not removed properly)

            sage: Semigroups().SetsWithAction().Algebras(QQ)
            Category of sets endowed with an action of a semigrou algebras over Rational Field
            sage: Semigroups().SetsWithAction().Algebras(QQ)   # todo: not implemented
            Category of sets endowed with an action of a semigrou algebras over Rational Field
        """

        # see the warning in sage.categories.set_with_action_functor.SetsWithActionCategory._algebras_extra_super_categories
        extra_super_categories = raw_getattr(SetsWithActionCategory, "_algebras_extra_super_categories")

        class ParentMethods:

            def semigroup(self):
                """
                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ)
                    sage: S = M.semigroup()
                """
                return self.basis().keys().semigroup()

            def action(self, s, x):
                """
                Return the action of ``s`` on ``x``.

                It is obtained by extending by linearity the action of
                ``s`` on the basis.

                INPUT:
                - ``x`` -- an element of ``self``
                - ``s`` -- an element of the semigroup acting on ``self``

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: S = M.semigroup()
                    sage: f2, f3 = S.semigroup_generators()
                    sage: x = M.an_element(); x
                    2*B[0] + 2*B[1] + 3*B[2]
                    sage: M.action(f2, x)
                    2*B[0] + 2*B[2] + 3*B[4]
                """
                action = self.basis().keys().action
                return x.map_support_skip_none(functools.partial(action, s))

            @cached_method
            def side(self):
                """
                Returns on which side the action occurs

                EXAMPLES::

                    sage: M = Semigroups().Finite().example()
                    sage: M.regular_representation(side='left').side()
                    'left'
                    sage: M.regular_representation(side='right').side()
                    'right'
                    sage: M.regular_representation(side="left").side.__module__
                    'sage.categories.sets_with_action'
                """
                return self.basis().keys().side()

            def character_of(self, s):
                """
                Return the trace of `s` as a linear morphism acting on ``self``

                INPUT:
                - `s` -- an element of the semigroup acting on ``self``

                EXAMPLES::

                    sage: S = AperiodicMonoids().Finite().example(3); S
                    The finite H-trivial monoid of order preserving maps on {1, .., 3}
                    sage: A = S.lr_regular_class_module(1, side="left")
                    sage: pi = S.monoid_generators()
                    sage: pi
                    Finite family {1: 113, 2: 122, -2: 133, -1: 223}
                    sage: A.character_of(S.one())
                    3
                    sage: A.character_of(pi[1])
                    1

                .. seealso: :meth:`Semigroups.SetsWithAction.ParentMethods.nr_fixed_points`
                """
                return self.basis().keys().nr_fixed_points(s)


            ########################################################################
            # EXPERIMENTAL, MOSTLY FOR H-TRIVIAL AND PROBABLY NOW USELESS
            ########################################################################

            def annihilator_with_apex(self, J):
                """
                INPUT:

                 - ``J`` -- the index of a regular J-class

                Let `A` be the set of all the elements of the
                semigroup which are not below `J` in `J`-order. This
                returns `Ann(self, A)`.
                """
                S = self.semigroup()
                P = S.j_poset_on_regular_classes()
                A = set(P).difference(P.principal_order_filter(J))
                # It is sufficient to take the generators of the highest J-classes in A
                A = P.order_ideal_generators(A)
                A = [x for I in A for x in S.regular_j_class_semigroup_generators(I)]
                return self.annihilator_of_subsemigroup(A)

            @cached_method
            def annihilator_module_with_apex(self, J):
                """
                INPUT:

                 - ``J`` -- the index of a regular J-class

                This attempts to construct a submodule of `self` with
                apex `J`. To this hand, this constructs the
                annihilator with apex `J` (see
                :meth:`annihilator_with_apex`), and checks whether it
                is indeed a submodule, and that its apex is `J`.

                If not, `None` is returned.

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: S = M.semigroup()

                This semigroup has two regular `J`-classes, with that
                indexed by `1` being smaller than that indexed by `0`
                (no luck in the random indexing chosen by Sage)::

                    sage: S.j_poset_on_regular_classes().cover_relations()
                    [[1, 0]]

                To those `J`-classes correspond two submodules of M::

                    sage: M.annihilator_module_with_apex(0)
                    Vector space of degree 10 and dimension 5 over Rational Field
                    Basis matrix:
                    [ 1  0  0  0  0 -1  0  0  0  0]
                    [ 0  1  0  0  0  0 -1  0  0  0]
                    [ 0  0  1  0  0  0  0 -1  0  0]
                    [ 0  0  0  1  0  0  0  0 -1  0]
                    [ 0  0  0  0  1  0  0  0  0 -1]

                    sage: M.annihilator_module_with_apex(1)
                    Vector space of degree 10 and dimension 10 over Rational Field
                    Basis matrix:
                    [1 0 0 0 0 0 0 0 0 0]
                    [0 1 0 0 0 0 0 0 0 0]
                    [0 0 1 0 0 0 0 0 0 0]
                    [0 0 0 1 0 0 0 0 0 0]
                    [0 0 0 0 1 0 0 0 0 0]
                    [0 0 0 0 0 1 0 0 0 0]
                    [0 0 0 0 0 0 1 0 0 0]
                    [0 0 0 0 0 0 0 1 0 0]
                    [0 0 0 0 0 0 0 0 1 0]
                    [0 0 0 0 0 0 0 0 0 1]

                    sage: M.annihilator_module_with_apex(0).apex()
                    0
                    sage: M.annihilator_module_with_apex(1).apex()
                    1

                We conclude with a case where the construction
                fails. Consider the right class module of the BiHecke
                Monoid of type A_3, indexed by `2314 = s_2 s_1`:

                    sage: W = SymmetricGroup(4)
                    sage: S = BiHeckeMonoid(W); S
                    bi-Hecke monoid of Symmetric group of order 4! as a permutation group
                    sage: w = W([2,3,1,4])
                    sage: R = S.lr_regular_class_module(w, side='right')
                    sage: list(f(W.one()) for f in R.basis().keys())
                    [(2,3), (1,2,3), ()]

                In this case, the construction fails::

                    sage: R.annihilator_module_with_apex(W([2,1,3,4]))   # long time
                    sage: R.annihilator_module_with_apex(W([1,3,2,4]))   # long time

                Indeed, the annihilator subspaces (which are
                respectively the kernels of pi_2 and pi_1) are not
                submodules::

                    sage: R.annihilator_with_apex(W([2,1,3,4]))
                    Vector space of degree 3 and dimension 2 over Rational Field
                    Basis matrix:
                    [ 1 -1  0]
                    [ 0  0  1]
                    sage: R.annihilator_with_apex(W([1,3,2,4]))
                    Vector space of degree 3 and dimension 2 over Rational Field
                    Basis matrix:
                    [ 1  0 -1]
                    [ 0  1  0]

                Could the map J -> R.annihilator_module_with_apexAnn(J)
                be extended to a morphism of posets from the poset of
                regular J-classes?

                Then, the pair of maps:

                J \mapsto self.annihilator_module_with_apex(J)

                and

                A \mapsto A.apex()

                should give a Galois connection.

                """
                S = self.semigroup()
                AnnJ = self.annihilator_with_apex(J)
                # If the apex of AnnJ is not J
                if all(self.action(s, self.from_vector(x)).is_zero()
                       for x in AnnJ.basis()
                       for s in S.regular_j_class_semigroup_generators(J)):
                    return None
                # If AnnJ is a submodule
                if any(self.action(s, self.from_vector(x)).to_vector() not in AnnJ
                       for x in AnnJ.basis()
                       for s in S.semigroup_generators()):
                    return None
                # Problem: make sure that the subspace AnnJ is private to self
                assert not hasattr(AnnJ, 'apex')
                AnnJ.apex = ConstantFunction(J)
                return AnnJ

            @cached_method
            def composition_series(self):
                """
                The (multiplicity-free) composition series of this module.

                This returns the set of (index of) `J`-classes `J`
                such that `J` is the apex of some submodule of ``self``.

                (conjectural: in fact only those such that there is an
                annihilator module with apex `J`)

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: M.composition_series()
                    {0, 1}
                """
                S = self.semigroup()
                R = self.basis().keys()
                try:
                    I = R.apex()
                    Js = [J for J in S.j_poset_on_regular_classes().principal_order_filter(I)]
                except AttributeError:
                    Js = S.regular_j_classes_keys()
                from sage.sets.set import Set
                return Set(J for J in Js if self.annihilator_module_with_apex(J) is not None)

            @cached_method
            def composition_series_poset(self):
                """
                The composition series of this module, endowed with `J`-order.

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: M.composition_series_poset()
                    Finite poset containing 2 elements
                    sage: M.composition_series_poset().cover_relations()
                    [[1, 0]]
                """
                S = self.semigroup()
                P = S.j_poset_on_regular_classes()
                return P.subposet(list(self.composition_series()))

            def annihilator_poset(self):
                """
                This computes all annihilator submodules with apex of
                ``self`` (see :meth:`self.annihilator_module_with_apex`)
                and order them for inclusion.

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: M.annihilator_poset()
                    Finite poset containing 2 elements
                    sage: M.annihilator_poset().cover_relations()
                    [[Vector space of degree 10 and dimension 5 over Rational Field
                      Basis matrix:
                      [ 1  0  0  0  0 -1  0  0  0  0]
                      [ 0  1  0  0  0  0 -1  0  0  0]
                      [ 0  0  1  0  0  0  0 -1  0  0]
                      [ 0  0  0  1  0  0  0  0 -1  0]
                      [ 0  0  0  0  1  0  0  0  0 -1],
                      Vector space of degree 10 and dimension 10 over Rational Field
                      Basis matrix:
                      [1 0 0 0 0 0 0 0 0 0]
                      [0 1 0 0 0 0 0 0 0 0]
                      [0 0 1 0 0 0 0 0 0 0]
                      [0 0 0 1 0 0 0 0 0 0]
                      [0 0 0 0 1 0 0 0 0 0]
                      [0 0 0 0 0 1 0 0 0 0]
                      [0 0 0 0 0 0 1 0 0 0]
                      [0 0 0 0 0 0 0 1 0 0]
                      [0 0 0 0 0 0 0 0 1 0]
                      [0 0 0 0 0 0 0 0 0 1]]]
                """
                from sage.combinat.posets.posets import Poset
                return Poset([[self.annihilator_with_apex(J) for J in self.composition_series()],
                              lambda M, N: M.is_subspace(N)])

            @cached_method
            def test_composition_series_poset(self):
                """
                Sanity checks for a for regular left/right class

                EXAMPLES::

                    sage: M = Semigroups().SetsWithAction().example().algebra(QQ); M
                    Free module generated by Representation of the monoid generated by <2,3> acting on Z/10 Z by multiplication over Rational Field
                    sage: M.test_composition_series_poset()
                """
                S = self.semigroup()
                R = self.basis().keys()
                composition_series_poset = self.composition_series_poset()
                assert composition_series_poset.is_meet_semilattice()
                #annihilator_poset = self.annihilator_poset()
                #annihilator_poset_dual = annihilator_poset.dual()
                #f = lambda J: annihilator_poset_dual(self.annihilator_with_apex(J))
                #assert composition_series_poset.is_poset_isomorphism(f, annihilator_poset_dual)

                # Dimension checks
                for J in self.composition_series():
                    assert self.annihilator_with_apex(J).dimension() == S.lr_regular_class(J, side=R.side()).cardinality()

                assert self.dimension() == sum(S.simple_module_dimension(J) for J in self.composition_series())

                # That can't work with the current definition of annihilator_module_with_apex.
                # j_poset = S.j_poset_on_regular_classes()
                # f = lambda J: composition_series_poset(self.annihilator_module_with_apex(J).apex())
                # assert j_poset.is_poset_morphism(f, composition_series_poset)

                return

                assert composition_series_poset.is_lattice()
                from sage.combinat.posets.lattices import LatticePoset
                composition_lattice = LatticePoset(composition_series_poset)
                # annihilator_poset = LatticePoset(annihilator_poset)

                # Check that self.annihilator_module_with_apex is a
                # lattice morphism from the composition poset to the
                # lattice of submodules of self. This is similar to
                # the above isomorphism test with the
                # annihilator_poset, except that we enforce that the
                # meet on submodules is given by intersection.

                f = lambda J: self.annihilator_module_with_apex(J)
                L = composition_lattice
                for J1 in self.composition_series():
                    for J2 in self.composition_series():
                        assert f(J1).intersection(f(J2)) == f( L.join(L(J1), L(J2)) )
