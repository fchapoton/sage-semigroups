r"""
Finite semigroups

Status: imported everything from finite_semigroups.py in the Sage-Combinat queue

::
    sage: import sage_semigroups # random
"""
#*****************************************************************************
#  Copyright (C) 2008-2009 Florent Hivert <florent.hivert at univ-rouen.fr>
#                2008-2017 Nicolas M. Thiery <nthiery at users.sf.net>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#******************************************************************************

from sage.misc.abstract_method import abstract_method
from sage.misc.cachefunc import cached_method
from sage.misc.misc import attrcall
from sage_semigroups.misc.sage_unittest import is_method
from sage_semigroups.categories.character_ring_functor import CharacterRingsCategory
from sage.categories.with_realizations import WithRealizationsCategory
from sage.categories.groups import Groups
from sage.categories.semigroups import Semigroups
from sage.sets.family import Family

class FiniteSemigroups:
    class ParentMethods:

        def is_aperiodic(self):
            """
            Returns whether this monoid is aperiodic

            This default implementation tests that the each element is
            of (ultimate) period 1.

            EXAMPLES::

                sage: S = Monoids().Aperiodic().Finite().example()
                sage: S.is_aperiodic()
                True

            The following monoid is not aperiodic::

                sage: S = Monoids().Finite().example(); S
                An example of a finite multiplicative monoid: the integers modulo 12
                sage: S.is_aperiodic()
                False

            To discover why, you can use::

                sage: Monoids().Aperiodic().parent_class._test_aperiodic.im_func(S)
                Traceback (most recent call last):
                ...
                AssertionError: 2 has ultimate period 2

            Indeed::

                sage: x = S(2)
                sage: [x, x^2, x^3, x^4, x^5]
                [2, 4, 8, 4, 8]

            .. seealso:: :class:`AperiodicMonoids`

            .. todo:: Find a nicer idiom for calling _test_aperiodic!
            """
            from sage.categories.monoids import Monoids
            assert self in Monoids() # pseudo_order is currently not implemented for semigroups
            try:
                Monoids().Aperiodic().parent_class._test_aperiodic.im_func(self, elements=self)
                return True
            except:
                pass
            return False

        # TODO: handle the duplication between is_l_trivial / is_r_trivial!
        @is_method
        def is_l_trivial(self, proof=True, **options):
            """
            Return whether ``self`` is L-trivial.

            .. seealso:: :meth:`is_r_trivial`
            """
            tester = self._tester(**options)
            for L in self.l_classes():
                tester.assert_( len(L) == 1, "The l-class %s is non trivial"%L )
            # from sage.categories.l_trivial_monoids import LTrivialMonoids
            # return LTrivialMonoids()

        @is_method
        def is_r_trivial(self, proof=True, **options):
            """
            Return whether ``self`` is R-trivial.

            INPUT:

            - ``raise_on_failure`` -- a boolean (default: False):
              whether to raise an exception in case of failure

            EXAMPLES::

                sage: S = Semigroups().Finite().example(); S
                An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')
                sage: S.category()
                Category of finite finitely generated semigroups
                sage: S.is_r_trivial()
                True
                sage: S.category()     # todo: not implemented
                Category of finite r trivial monoids

                sage: S = Monoids().Aperiodic().Finite().example(); S
                The finite H-trivial monoid of order preserving maps on {1, 2, 3}
                sage: S.is_r_trivial()
                False

            With ``raise_on_failure=True`` an exception is raised,
            giving information on the reason for the failure::

                sage: S.is_r_trivial(raise_on_failure=True)
                Traceback (most recent call last):
                ...
                AssertionError: The r-class {...,...} is non trivial

            Even more information can then be recovered by
            introspection using the debugger (see :meth:`pdb.pm`).

            This method is also used to implement
            ``RTrivialMonoids.Finite.ParentMethods._test_r_trivial``::

                sage: S = Semigroups().RTrivial().example(); S
                An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c')
                sage: S.category()
                Category of finite aperiodic r trivial finitely generated semigroups
                sage: S._test_r_trivial()

            .. SEEALSO::

                - :class:`sage.misc.sage_unittest.is_method` for the infrastructure of is_method's
                - :meth:`pdb.pm` for how to recover even more information by introspection.

            .. note::

                Refining the category with ``RTrivialMonoids()`` after
                a succefull call to ``is_r_trivial()`` is not yet
                implemented. The reason is that this is incompatible
                with the current hack of setting _mul_ in the element
                class in Magmas.ParentMethods.__init_extra__.
            """
            tester = self._tester(**options)
            for R in self.r_classes():
                tester.assert_( len(R) == 1, "The r-class %s is non trivial"%R )
            # from sage.categories.r_trivial_monoids import RTrivialMonoids
            # return RTrivialMonoids() 

        @is_method
        def is_DG(self, proof=True, **options):
            r"""
            Returns whether the regular h_classes are all groups

            EXAMPLES::

                sage: S = Semigroups().Finite().example(); S
                An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c', 'd')
                sage: S.is_DG()
                True

                sage: S = Monoids().HTrivial().Finite().example(); S
                The finite H-trivial monoid of order preserving maps on {1, 2, 3}
                sage: S.is_DG()
                False

                sage: S = FiniteSetMaps(2); S
                Maps from {0, 1} to itself
                sage: S.is_DG()
                True
                sage: S = FiniteSetMaps(3); S
                Maps from {0, 1, 2} to itself
                sage: S.is_DG()
                False

                sage: S = Groups().Finite().example(); S
                General Linear Group of degree 2 over Finite Field of size 3
                sage: S.is_DG()
                True
            """
            tester = self._tester(**options)
            for i in self.regular_j_classes_keys():
                J = self.regular_j_class(i)
                H = self.lr_regular_class(i,side="h")
                number_of_h_classes = J.cardinality() / H.cardinality()
                number_of_idempotests = len(self.j_class_idempotents(i))
                assert number_of_idempotests <= number_of_h_classes
                tester.assert_(number_of_idempotests == number_of_h_classes,
                               "At least one H-class does not contain an idempotent")


        @cached_method
        def is_DA(self):
            r"""
            Returns whether this monoid is in DA

            A monoid is in DA if any regular element is idempotent. In
            particular, it is aperiodic.
            """
            # FIXME: this is a fairly stupid implementation
            return self.is_aperiodic() and self.is_DG()

        @cached_method
        def is_basic(self):
            """
            Returns whether this semigroup is basic

            A semigroup is basic if all its linear representations are
            one-dimensional.

            EXAMPLES:

            Groups are basic if and only if they are commutative::

                sage: G = CyclicPermutationGroup(3)
                sage: G.is_basic()
                True
                sage: G = SymmetricGroup(3)
                sage: G.is_basic()
                False

            Aperiodic monoids are basic if and only if they are in DA::

                sage: S = Monoids().HTrivial().Finite().example(); S
                The finite H-trivial monoid of order preserving maps on {1, 2, 3}
                sage: S.is_basic()
                False

            ::

                sage: FiniteSetMaps(2).is_basic()
                True
                sage: FiniteSetMaps(3).is_basic()
                False

            .. TODO::

                Add tests with non aperiodic Rees Matrix monoids once
                they are implemented.

            .. WARNING::

                The answer actually depends on the ground field for
                the representations.  The current implementation is
                only valid for representations over a field of
                characteristic zero containing sufficiently many roots
                of unity.

                It checks that the groups associated to each j_class
                are all commutative, and that all H-classes are groups
                (i.e. that each eggbox-matrix contains only 1's).

            .. TODO::

                This method should be moved and called as, e.g.::

                    sage: S.algebra(QQ).is_basic()   # todo: not implemented

            """
            return self.is_DG() and all(group.is_commutative() for group in self.groups_of_regular_j_classes())

        def green_classes(self, side = "twosided"):
            r"""
            INPUT:

             - ``side`` -- "left", "right", or "twosided"

            Depending on the value of ``side``, returns respectively
            the `L`-classes, `R`-classes, or `J`-classes of ``self``,
            sorted decreasingly along a linear extension of
            respectively `L`, `R` or `J`-order.

            EXAMPLES::

                sage: M = Semigroups().Finite().example(('a','b')); M
                An example of a finite semigroup: the left regular band generated by ('a', 'b')
                sage: M.green_classes()
                [{'a'}, {'b'}, {'ab', 'ba'}]
                sage: M.green_classes(side="left")
                [{'a'}, {'b'}, {'ab', 'ba'}]
                sage: M.green_classes(side="right")
                [{'b'}, {'a'}, {'ab'}, {'ba'}]
            """
            G = self.cayley_graph_cached(side=side, simple=True).strongly_connected_components_digraph()
            from sage.combinat.posets.posets import Poset
            P = Poset(G, facade = True)
            return P.linear_extension()

        @cached_method
        def j_classes(self):
            r"""
            Returns the `J`-classes of the semigroup.

            Two elements `f` and `g` of a semigroup are in the same
            `J`-class if `f=ugv` and `g=u'fv'` for some `u`,`v`,`u'`,
            and `v'` in the semigroup.

            OUTPUT:

             All the `J`-classes of self, as a list of lists.

            In this default implementation the `J`-classes are ordered
            along a linear extension of the `J` order.

            .. TODO:: do we want to enforce that this is always the case?

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes()))
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
            return Family(self.green_classes(side = "twosided"))

        @cached_method
        def r_classes(self):
            r"""
            Returns the `R`-classes of the semigroup.

            Two elements `f` and `g` of a semigroup are in the same
            `R`-class if `f=gv` and `g=fv'` for some `v` and `v'` in
            the semigroup.

            OUTPUT::

             All the `J`-classes of self, as a list of lists.

            In this default implementation the `J`-classes are ordered
            along a linear extension of the `J` order.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes()))
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
            return self.green_classes(side = "right")

        @cached_method
        def l_classes(self):
            r"""
            Returns the `L`-classes of the semigroup.

            Two elements `f` and `g` of a semigroup are in the same
            `L`-class if `f=vg` and `g=v'f` for some `v` and `v'` in
            the semigroup.

            OUTPUT::

              All the `R`-classes of self, as a list of lists.

            In this default implementation the `J`-classes are ordered
            along a linear extension of the `J` order.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes()))
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
            return self.green_classes(side = "left")


        @cached_method
        def j_class_index(self, x):
            r"""
            INPUT:

             - ``x`` - an element of self

            Returns the index of the j-class of ``self``

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: a,b,c = S.semigroup_generators()
                sage: S.j_class_index(a*b*c)       # random (arbitrary choice)
                6

                sage: for j_class in S.j_classes():
                ...       print j_class, "->", set(S.j_class_index(x) for x in j_class)
                {'c'} -> set([0])
                {'a'} -> set([1])
                {'ac', 'ca'} -> set([2])
                {'b'} -> set([3])
                {'cb', 'bc'} -> set([4])
                {'ab', 'ba'} -> set([5])
                {'acb', 'cba', 'abc', 'cab', 'bca', 'bac'} -> set([6])

            We now check that each j-class is mapped to a single index::

                sage: [len(set(S.j_class_index(x) for x in j_class)) for j_class in S.j_classes()]
                [1, 1, 1, 1, 1, 1, 1]

            .. note:: in this implementation, the result of this
                method is computed at once on all the elements of
                ``self``, and cached.
            """
            j_classes = self.j_classes()
            for i in j_classes.keys():
                for y in j_classes[i]:
                    self.j_class_index.set_cache(i, y)
            return self.j_class_index(x)

        @cached_method
        def j_class_representative(self, i):
            r"""
            INPUT:

             - ``i`` - the index of a J-class of ``self``

            Returns a representative of the J-class index by ``i``.

            If the J-class is regular, then this representative is
            chosen to be idempotent.

            EXAMPLES::

                sage: S = Monoids().Finite().example()
                sage: I = S.j_classes().keys(); I
                [0, 1, 2, 3, 4, 5]
                sage: S.j_class_representative(0)
                1
            """
            def representative(l):
                for x in l:
                    if x.is_idempotent():
                        return x
                return l[0]
            return representative(self.j_classes()[i])

        @cached_method
        def j_class(self, x):
            assert x in self
            return self.j_classes()[self.j_class_index(x)]

        @cached_method
        def regular_j_class(self, i):
            """
            Returns the regular J-class indexed by `i`

            Like :meth:`j_transversal`, this uses the indexing of the
            regular `J`-classes (which is not that of the `J`-classes.

            EXAMPLES::

                sage: S = Semigroups().Finite().example()
                sage: S.regular_j_class(4)
                {'ab', 'ba'}

            .. seealso:: :meth:`regular_j_classes`
            """
            return self.j_class(self.j_transversal_of_idempotents()[i])

        @cached_method
        def regular_j_classes(self):
            r"""
            Returns the regular J-classes of ``self``

            EXAMPLES::

                sage: S = Semigroups().Finite().example(('a','b','c'))
                sage: S.regular_j_classes()
                Finite family {0: {'c'}, 1: {'a'}, 2: {'ac', 'ca'}, 3: {'b'},
                               4: {'cb', 'bc'}, 5: {'ab', 'ba'},
                               6: {'acb', 'cba', 'abc', 'cab', 'bca', 'bac'}}
            """
            return Family(self.regular_j_classes_keys(), self.regular_j_class)

        @cached_method
        def regular_j_class_semigroup_generators(self, i):
            """
            Semigroup generators for a regular `J` class

            INPUT:

             - ``i``: the index of some regular `J`-class `J` of this semigroup

            This returns a set of semigroup generators of `J`. This
            dummy implementation returns the `J`-class itself.

            EXAMPLES::

                sage: S = Semigroups().Finite().example()
                sage: S.regular_j_class_semigroup_generators(1)
                {'a'}
            """
            return self.regular_j_class(i)

        @cached_method
        def j_class_idempotents(self, i, regular=False):
            """
            Returns the idempotents of the `J`-class indexed by `i`

            INPUT:

             - ``i`` the index of a J-class of ``self``
            """
            if regular:
                j_class = self.j_classes()[i]
            else:
                j_class = self.regular_j_classes()[i]
            return [e for e in j_class if e.is_idempotent()]

        @cached_method
        def j_transversal(self):
            r"""
            Returns the distinguished representatives of each J-class.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: S.j_transversal()            # random (arbitrary choice)
                ['a', 'ab', 'b', 'c', 'ca', 'cab', 'cb']
                sage: len(S.j_transversal())
                7
            """
            return Family(self.j_classes().keys(), self.j_class_representative)

        @cached_method
        def j_poset(self):
            r"""

            Returns the j-order on the j-classes, as a poset on the
            indices of the j-classes. For two such indices `i` and
            `j`, and `x` and `y` in corresponding J-classes, one has:

               `i \le j  \Leftrightarrow x \in S y S  \Leftrightarrow  S x S \subset S y S`

            In particular, the identity (when it exists) is the unique
            maximal element of this poset.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: P = S.j_poset(); P
                Finite poset containing 7 elements
                sage: P.cover_relations()    # random (arbitrary choice)
                [['cab', 'ca'], ['cab', 'cb'], ['cab', 'ab'], ['ca', 'c'], ['ca', 'a'], ['cb', 'b'], ['cb', 'c'], ['ab', 'b'], ['ab', 'a']]
                sage: len(P.cover_relations())
                9
            """
            from sage.graphs.graph import DiGraph
            from sage.combinat.posets.posets import Poset
            # This is more or less duplicating what strongly_connected_components_digraph does!!!
            G = DiGraph()
            G.add_vertices(self.j_classes().keys())
            for (x,y,_) in self.cayley_graph_cached(side="twosided", simple=True).edge_iterator():
                x = self.j_class_index(x)
                y = self.j_class_index(y)
                if x != y:
                    G.add_edge(y, x)
            return Poset(G)

        def j_lequal(self, x, y):
            r"""
            J-preorder comparison

            INPUT:

             - ``x``, ``y`` -- elements or ``self``

            Returns whether ``x`` is smaller than ``y` in J-preorder,
            that is `SxS \subset SyS`.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b')); S
                An example of a finite semigroup: the left regular band generated by ('a', 'b')
                sage: [ (x,y) for x in S for y in S if S.j_lequal(x,y) ]
                [('a', 'a'), ('b', 'b'),
                 ('ab', 'a'), ('ab', 'b'), ('ab', 'ab'), ('ab', 'ba'),
                 ('ba', 'a'), ('ba', 'b'), ('ba', 'ab'), ('ba', 'ba')]
            """
            P = self.j_poset()
            return P.is_lequal(self.j_class_index(x), self.j_class_index(y))

        @cached_method
        def j_poset_on_regular_classes(self):
            r"""
            Returns the J-order on the regular J-classes, as a facade
            poset on the indices of J-classes

            TODO: add tests on a semigroup having non regular j-classes.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b','c'))
                sage: P = S.j_poset_on_regular_classes(); P
                Finite poset containing 7 elements
                sage: P.cover_relations()    # random (arbitrary choice)
                [[6, 5], [6, 4], [6, 2], [5, 3], [5, 1], [4, 3], [4, 0], [2, 1], [2, 0]]
                sage: len(P.cover_relations())
                9
            """
            transversal = self.j_transversal_of_idempotents()
            from sage.combinat.posets.posets import Poset
            return Poset((transversal.keys(), lambda i,j: self.j_lequal(transversal[i], transversal[j])), facade=True)

        @cached_method
        def j_classes_of_idempotents(self):
            r"""
            Returns all the idempotents of self, grouped by J-class.

            OUTPUT:

             a list of lists.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: sorted(map(sorted, S.j_classes_of_idempotents()))
                [['a'], ['ab', 'ba'], ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'], ['ac', 'ca'], ['b'], ['bc', 'cb'], ['c']]
            """
            return filter(lambda l: len(l) > 0,
                          map(lambda cl: filter(attrcall('is_idempotent'), cl),
                              self.j_classes()))

        # or regular_j_classes_transversal?
        @cached_method
        def j_transversal_of_idempotents(self):
            r"""
            Returns a transversal of the j-classes of idempotents

            OUTPUT:

             - A family of idempotents containing exactly one
               idempotent per regular j-class. Furthermore this family
               is sorted decreasingly along a linear extension of
               `J`-order.

            If this monoid is aperiodic, the index set of this family
            is used to index the simple modules of this finite
            semigroup (see
            :meth:`HTrivialMonoids.Finite.ParentMethods.simple_modules_index_set`).

            In this default implementation, the transversal is indexed
            by `0,1,...`. Subclasses are encouraged to use a more
            meaningful indexing whenever possible.

            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: S.j_transversal_of_idempotents()          # random
                Family ('acb', 'cb', 'ac', 'c', 'ab', 'b', 'a')
                sage: S.j_transversal_of_idempotents().keys()
                [0, 1, 2, 3, 4, 5, 6]

            TESTS::

                sage: sorted(S.j_transversal_of_idempotents())
                ['a', 'ab', 'ac', 'acb', 'b', 'c', 'cb']
            """
            def first_idempotent(l):
                for x in l:
                    if x.is_idempotent():
                        return x
                return None
            transversal = filter(lambda x: x is not None,
                                 map(first_idempotent, self.j_classes()))
            if self.index_of_regular_j_class is NotImplemented:
                return Family( transversal )
            else:
                transversal = [(self.index_of_regular_j_class(e), e)
                               for e in transversal]
                indices = [i for (i,e) in transversal]
                return Family(indices, dict(transversal).__getitem__)

        @abstract_method(optional=True)
        def index_of_regular_j_class(self, idempotent):
            """
            Returns the index that should be used for an idempotent in the transversal
            """

        @cached_method
        def regular_j_classes_keys(self):
            """
            EXAMPLES::

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c')); S
                An example of a finite semigroup: the left regular band generated by ('a', 'b', 'c')
                sage: S.regular_j_classes_keys()
                [0, 1, 2, 3, 4, 5, 6]
            """
            return self.j_transversal_of_idempotents().keys()

        # TODO: compute eJe, where J is the J-class of e
        # TODO: construct the action of self on it, as a permutation group
        # TODO: compute the simple modules for that permutation group, and
        # fix the above

        @cached_method
        def lr_class_of(self, x, side='right'):
            """
            Return the ``side``-class of ``x``, endowed with its natural action of ``self``

            INPUT:

            - ``side`` -- 'left', 'right', or 'h' (default: 'right')
            - ``x`` -- an element of ``self``

            EXAMPLES::

                sage: F = FiniteSetMaps(3, action='right'); F
                Maps from {0, 1, 2} to itself
                sage: e = F([1,1,2])

            The right class of `e` consists of all functions with the same fibers::

                sage: F.lr_class_of(e)
                {[1, 1, 0], [0, 0, 2], [2, 2, 1], [1, 1, 2], [0, 0, 1], [2, 2, 0]} endowed with an action of Maps from {0, 1, 2} to itself
                sage: F.lr_class_of(e, side="right")
                {[1, 1, 0], [0, 0, 2], [2, 2, 1], [1, 1, 2], [0, 0, 1], [2, 2, 0]} endowed with an action of Maps from {0, 1, 2} to itself

            The left class of `e` consists of all functions with the same image set::

                sage: F.lr_class_of(e, side='left')
                {[1, 2, 1], [1, 2, 2], [2, 1, 2], [2, 2, 1], [2, 1, 1], [1, 1, 2]} endowed with an action of Maps from {0, 1, 2} to itself

            The H-class of `e` is the intersection of the above, that
            is the set of all functions with same fibers and image set
            as `e`::

                sage: F.lr_class_of(e, side='h')
                sage: F.lr_class_of(e, side='h')
                {[2, 2, 1], [1, 1, 2]}

            Note that, in this case, `e` is an idempotent, and
            therefore the result is a group.

            .. seealso:: :meth:`j_transversal_of_idempotents`
            """
            assert side in ['left', 'right','h']
            if side == 'h':
                from sage.sets.set import Set
                return Set(self.lr_class_of(x, side='left')).intersection(Set(self.lr_class_of(x, side='right')))
            reg_rep = self.with_regular_action(side=side)
            module = reg_rep.subquotient(reg_rep.class_of(x))
            from sage.misc.constant_function import ConstantFunction
            module.side = ConstantFunction(side)
            return module

        @cached_method
        def lr_class(self, J, side='right'):
            """
            Left / Right regular classes

            INPUT:
             - ``side`` -- 'left' or 'right' (default: 'right')
             - ``J`` -- the index of a `J`-class

            Recall that all left (resp. right) classes in the
            `J`-class indexed by `J` are isomorphic.  This returns the
            left (resp. right) class containing the canonical
            representative of the `J`-class.

            EXAMPLES::

                sage: S = Monoids().HTrivial().Finite().example(); S
                The finite H-trivial monoid of order preserving maps on {1, .., 3}

                sage: side = "right"
                sage: S.lr_class(0, side=side)
                {123} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: S.lr_class(1, side=side)
                {..., ...} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: S.lr_class(2, side=side)
                {333} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}

                sage: side = "left"
                sage: S.lr_class(0, side=side)
                {123} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: S.lr_class(1, side=side)
                {..., ..., ...} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: S.lr_class(2, side=side)
                {333, 222, 111} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}

            .. seealso:: :meth:`j_transversal`
            """
            return self.lr_class_of(self.j_transversal()[J], side = side)


        @cached_method
        def lr_regular_class(self, J, side='right'):
            """
            Left / Right regular classes

            INPUT:
             - ``side`` -- 'left' or 'right' (default: 'right')
             - ``J`` -- the index of a regular `J`-class

            Recall that all left (resp. right) in the `J`-class
            indexed by `J` are isomorphic. This returns the right
            regular glass containing the canonical idempotent
            representative of the `J`-class.


            EXAMPLES::

                sage: M = Monoids().HTrivial().Finite().example(); M
                The finite H-trivial monoid of order preserving maps on {1, .., 3}
                sage: C = M.lr_regular_class(1); C
                {..., ...} endowed with an action of The finite H-trivial monoid of order preserving maps on {1, .., 3}

            `C` contains the canonical idempotent representative::

                sage: M.j_transversal_of_idempotents()[1] in C
                True

            Up to appropriate indexing, this method and
            :meth:`lr_class` return the same object::

                sage: C is M.lr_class(1)
                True

            .. todo:: fuse lr_class and lr_regular_class with an option regular = True

            .. seealso::

            - :meth:`lr_class`
            - :meth:`j_transversal_of_idempotents`

            """
            module = self.lr_class_of(self.j_transversal_of_idempotents()[J], side = side)
            from sage.misc.constant_function import ConstantFunction
            module.apex = ConstantFunction(J)
            return module

        @cached_method
        def lr_regular_class_module(self, J, base_ring = None, side='right'):
            """
            Left / Right regular class modules

            INPUT:
            - ``J`` -- the index of a regular `J`-class
            - ``base_ring`` -- a ring (default: ``QQ``)
            - ``side`` -- 'left' or 'right' (default: 'right')

            Recall that all right classes in the `J`-class indexed by
            `J` are isomorphic.  This returns the module of the right
            regular glasc containing the canonical idempotent
            representative of the `J` class.

            .. seealso:: :meth:`j_transversal_of_idempotents`
            """
            return self.lr_regular_class(J, side = side).algebra(base_ring)

        @cached_method
        def group_of_regular_j_class(self, J):
            r"""
            Returns the group associated to the regular `J`-class indexed by `J`

            INPUT:

            - ``J`` -- the index of a regular `J`-class

            This returns the `H` class containing the canonical
            idempotent representative of the `J`-class.

            EXAMPLES::

                sage: M = FiniteSetMaps(3); M
                Maps from {0, 1, 2} to itself
                sage: G = M.group_of_regular_j_class(0); G
                A subobject of Maps from {1, 2, 3} to itself

            The highest `H`-class coincides with the highest
            `J`-class, which is the symmetric group acting on
            `\{0,1,2\}`::

                sage: G.cardinality()
                6
                sage: sorted( x.lift() for x in G )
                [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]

            For the middle `H`-class, the group is in bijection with
            the symmetric group of order `2`::

                sage: G = M.group_of_regular_j_class(1); G
                sage: G.cardinality()
                sage: sorted( x.lift() for x in G )
                [[0, 1, 0], [1, 0, 1]]
            """
            return self.subquotient(self.lr_regular_class(J, side='h'),
                                    category = Groups() & Semigroups().Finite().Subobjects())


        def groups_of_regular_j_classes(self):
            """
            Returns the groups associated to each regular `J`-class

            .. SEEALSO:: :meth:`group_of_regular_j_class`

            EXAMPLES::

                sage: M = FiniteSetMaps(3); M
                Maps from {0, 1, 2} to itself
                sage: groups = M.groups_of_regular_j_classes(); groups
                A subobject of Maps from {1, 2, 3} to itself
                Finite family {0: A subobject of Maps from {0, .., 2} to itself,
                               1: A subobject of Maps from {0, .., 2} to itself,
                               2: A subobject of Maps from {0, .., 2} to itself}
                sage: list(group) for group in groups
                sage: [sorted(group, key=str) for group in groups]
                [[[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]],
                 [[0, 1, 0], [1, 0, 1]],
                 [[2, 2, 2]]]
            """
            return Family(self.regular_j_classes_keys(), self.group_of_regular_j_class)

        def h_le_on_idempotents(self, e, f):
            """
            INPUT:
             - ``e``, ``f``: idempotents of ``self``

            Returns whether `e <= f` in H order, that is `ef = fe =e`

            EXAMPLES:

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: a,b,c = S.semigroup_generators()
                sage: S.h_le_on_idempotents(a*b*a, a)
                True
                sage: le = S.h_le_on_idempotents
                sage: a*b, b*a, a*b*a
                ('ab', 'ba', 'ab')
                sage: le(a,a), le(b,a), le(a*b,a), le(b*a,a), le(a*b*a,a)
                (True, False, True, False, True)
            """
            assert e.is_idempotent() and f.is_idempotent()
            return e*f == e and f*e == e

        @cached_method
        def h_poset_on_idempotents(self):
            """
            Returns the h-poset on the idempotents of ``self``

            EXAMPLES:

                sage: S = Semigroups().Finite().example(alphabet=('a','b', 'c'))
                sage: P = S.h_poset_on_idempotents(); P
                Finite poset containing 15 elements
                sage: a,b,c = S.semigroup_generators()
                sage: a*b, b*a, a*b*a
                ('ab', 'ba', 'ab')
                sage: P(a) <= P(a), P(b) <= P(a), P(a*b) <= P(a), P(b*a) <= P(a), P(a*b*a) <= P(a)
                (True, False, True, False, True)
                sage: sorted(P.cover_relations())
                [['cab', 'ca'], ['bac', 'ba'], ['abc', 'ab'], ['ab', 'a'], ['bca', 'bc'], ['ca', 'c'], ['cba', 'cb'], ['cb', 'c'], ['bc', 'b'], ['ba', 'b'], ['acb', 'ac'], ['ac', 'a']]
            """
            from sage.combinat.posets.posets import Poset
            return Poset((self.idempotents(), self.h_le_on_idempotents))

        def character_ring(self, modules_base_ring = None, base_ring = None, side = 'right', q = None):
            """
            Returns the character ring of ``self``

            EXAMPLES::

                sage: S = Semigroups().Finite().example()
                sage: S.rename("S")

                sage: A = S.character_ring(); A
                The right-character ring of S over Rational Field

                sage: A.category()
                Category of character rings of finite semigroups over Integer Ring with realizations

                sage: QQ.<q> = QQ[]
                sage: A = S.character_ring(q = q); A
                The right-character ring of S over Rational Field
            """
            from sage.rings.rational_field import QQ
            if modules_base_ring is None:
                modules_base_ring = QQ
            from sage.rings.integer_ring import ZZ
            if q is None:
                q = ZZ.one()
            if base_ring is None:
                base_ring = q.parent()
            from sage.categories.rings import Rings
            assert base_ring in Rings()
            assert q in base_ring
            from sage_semigroups.monoids.character_ring import AbstractCharacterRing
            return AbstractCharacterRing(self, modules_base_ring, base_ring, side = side, q = q)

    class ElementMethods:
        def ideal(self, side = "twosided"):
            """
            INPUT:

             - ``side``: [default: "twosided"] "left", "right" or "twosided"

            Return the principal ideal generated by ``self``.

            See also :meth:`Semigroups().Finite.ParentMethods.ideal`.

            EXAMPLES::

                sage: S = Semigroups().Finite().example()
                sage: list(S('cab').ideal(side="left"))
                ['cab', 'dcab', 'adcb', 'acb', 'bdca', 'bca', 'abdc',
                'cadb', 'acdb', 'bacd', 'abcd', 'cbad', 'abc', 'acbd',
                'dbac', 'dabc', 'cbda', 'bcad', 'cabd', 'dcba',
                'bdac', 'cba', 'badc', 'bac', 'cdab', 'dacb', 'dbca',
                'cdba', 'adbc', 'bcda']
            """
            return self.parent().ideal([self], side = side)

    class CharacterRings(CharacterRingsCategory):

        def super_categories(self):
            """
            EXAMPLES::

                sage: Semigroups().Finite().CharacterRings(ZZ).super_categories()
                [Category of finite dimensional modules with basis over Integer Ring]
            """
            from sage.categories.modules import Modules
            return [Modules(self.base_ring()).WithBasis().FiniteDimensional()]

        class WithRealizations(WithRealizationsCategory):

            class ParentMethods:

                @abstract_method
                def base(self):
                    """
                    Returns the object of which this is a character ring

                    EXAMPLES::

                        sage: GL(3,3).character_ring(QQ).base()
                        General Linear Group of degree 3 over Finite Field of size 3
                    """

                def character_ring_category_disabled(self):
                    """
                    EXAMPLES::

                        sage: A = Semigroups().Finite().example().character_ring(GF(2))
                        sage: A.character_ring_category()
                        Category of character rings of finite semigroups over Integer Ring
                    """
                    from sage.categories.modules import Modules
                    return Modules(self.base_ring()).FiniteDimensional().WithBasis() & self.Realizations()

                @cached_method
                def S(self):
                    """
                    Return the ring of characters, in the basis of the characters of the simple modules

                    EXAMPLES::

                        sage: M = Monoids().HTrivial().Finite().example()
                        sage: M.rename("S")
                        sage: S = M.character_ring(QQ).S(); S
                        The right-character ring of S over Rational Field in the basis of characters of simple right modules
                        sage: S.category()
                        Join of Category of realizations of character rings of finite h trivial monoids over Integer Ring and The category of realizations of The right-character ring of S over Rational Field
                        sage: S.basis().keys()
                        {0, 1, 2}
                        sage: S.realization_of()
                        The right-character ring of S over Rational Field
                        sage: S in Modules(ZZ).WithBasis()
                        True
                        sage: TestSuite(S).run()

                    """
                    from sage_semigroups.monoids.character_ring import CharacterRing
                    return CharacterRing(self, prefix = "S", modules = "simple %s"%self.side())

                @cached_method
                def P(self):
                    """
                    Return the ring of characters, in the basis of the characters of the projective modules

                    .. warning:: this is only guaranteed to be a basis for
                        finite aperiodic monoids.

                    EXAMPLES::

                        sage: S = Monoids().HTrivial().Finite().example()
                        sage: S.rename("S")
                        sage: S.character_ring(QQ).P()
                        The right-character ring of S over Rational Field in the basis of characters of projective indecomposable right modules
                    """
                    from sage_semigroups.monoids.character_ring import CharacterRing
                    return CharacterRing(self, prefix = "P", modules = "projective indecomposable %s"%self.side())

                def E(self):
                    """
                    Return the ring of characters, in the basis of the characters of the modules generated by the idempotents of the monoid

                    .. warning:: this is only guaranteed to be a basis for
                        finite aperiodic monoids.

                    EXAMPLES::

                        sage: S = Monoids().HTrivial().Finite().example()
                        sage: S.rename("S")
                        sage: S.character_ring(QQ).E()
                        The right-character ring of S over Rational Field in the basis of characters of projective e right modules

                    .. todo:: improve the name!
                    """
                    from sage_semigroups.monoids.character_ring import CharacterRing
                    return CharacterRing(self, prefix = "E", modules = "projective e %s"%self.side())
